# 学什么
* 如何将显示世界的问题信息化
* 如何高效处理而创造价值

# 绪论
## 基本概念
* 数据
* 数据元素、数据项
* 数据结构（有关系数据元素的集合）、数据对象（相同性质的数据元素集合）
* 数据类型（原子类型、结构类型）、抽象数据类型ADT（相当于定义了数据结构中的逻辑结构和数据运算，与存储结构无关）
  
## 数据结构三要素
* 逻辑结构
  * 集合（无逻辑联系）
  * 线性结构（一对一、前驱、后继）
  * 树形结构（一对多）
  * 图结构（多对多）
* 物理结构（存储结构）
  * 顺序存储（物理上连续）
  * 非顺序存储（离散）
    * 链式存储
    * 索引存储
    *  散列存储
* 数据的运算

# 算法
程序=数据结构（要处理的信息）+算法（处理信息的步骤）
## 特性
* 有穷性（有穷步骤、有穷时间）
* 确定性（相同输入得到相同输出）
* 可行性（基本运算有限次）
* 输入输出
## 好算法特质
* 正确性
* 可读性
* 健壮性（对于非法数据进行适当处理）
* 高效率（时间复杂度低）与低存储量需求（空间复杂度低）

# 算法效率
## 时间复杂度
* 计算方法
  * 找基本操作（最深层循环）
  * 执行次数$x=f(n)$
  * $x$的数量级就是时间复杂度$T(n)$
* Tips
  
  * 顺序执行的代码只会影响常数项，可以忽略
  * 只需挑循环中的一个基本操作分析它的执行次数与$n$的关系即可
  * 如果有多层嵌套循环，只需关注最深层循环循环了多少次
  * 当时间复杂度和输入有关系时，一般考虑最坏时间复杂度或平均时间复杂度（数学期望）
* $O(1)<O(\log _2n)<O(n)<O(n\log _2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$
## 空间复杂度
* 数组
  ```C
  void test(int n){
    int flag[n]; //长度为n的数组
    int i;
    //省略很多代码...
  }
  ```
  空间复杂度为$O(n)$
* 函数递归调用
  ```C
  void loveYou(int n){
    int a,b,c;
    if (n>1){
      loveYou(n-1);
    }
    printf("I Love You")
  }
  ```
 * Tips
  * 算法原地工作：空间复杂度为常数阶
  * 函数递归调用时，如果每次调用为常数阶，那么空间复杂度与递归深度即$O(n)$；如果每次调用不为常数阶，需要具体计算

