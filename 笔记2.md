# 递归
## 两个特点
* 调用自身
* 结束条件
## 区分两个例子
* ```Python
    def func1(x):
        if x>0:
            print(x)
            func1(x-1)
    #会打印出x,x-1,x-2,...,1
  ```
* ```Python
    def func2(x):
        if x>0:
            func1(x-1)
            print(x)
    #会打印出1,2,3,...,x
  ```
## 汉诺塔问题
```Python
def hanoi(n, a, b, c):#n个盘子从a经b移动到c
    if n > 0:
        hanoi(n-1, a, c, b)
        print("从"+a+"移动到"+c)
        hanoi(n-1, b, a, c)
```

# 查找
## 顺序查找(Linear Search)
```Python
    def linear_search(li, value):
        for i, v in enumerate(data_set):
            if v == value:
                return i
        return None
```
时间复杂度：$O(n)$
## 二分查找(Binary Search)
需要在有序条件下
```Python
    def binary_search(li, value):
        left = 0
        right = len(li) - 1 
        while left <= right: #候选区有值
            mid = (left + right) // 2
            if li[mid] == value:
                return mid
            elif li[mid] > value:
                right = mid - 1
            elif li[mid] < value:
                left = mid + 1
        return None
```
时间复杂度：$O(\log_2n)$

Python内置的index函数是顺序查找

# 排序
## 常规排序
### 冒泡排序(Bubble Sort)
一趟排出一个最大的数
```Python
    def Bubble_sort(li):
    for i in range(0, len(li)-1): #循环趟数，每趟可以排出一个最大数
        for j in range(0, len(li)-i-1): #每趟需要交换多少次
            if li[j] > li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]
```
时间复杂度：$O(n^2)$
优化：如果一趟后列表没有发生任何变化，那么认为已经排好了
```Python
    def Bubble_sort(li):
    for i in range(0, len(li)-1): #循环趟数，每趟可以排出一个最大数
        exchange = False
        for j in range(0, len(li)-i-1): #每趟需要交换多少次
            if li[j] > li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]
                exchange = True #发生交换
        if not exchange: #如果某一趟循环没有发生交换
            return 
```
### 选择排序(Select Sort)
* 简单版
```Python
    def Select_sort_simple(li):
        li_new = []
        for i in range(0, len(li)):
            min_val = min(li)
            li_new.append(min_val)
            li.remove(min_val)
        return li_new
```

时间复杂度：$O(n^2)$，空间复杂度也高（开辟了新的列表）
* 优化版
```Python
    def Select_sort(li):
        for i in range(0, len(li)-1): #第i趟
            min_loc = i
            for j in range(i+1, len(li)): #加1是为了不和自己比，节约一次
                if li[min_loc] > li[j]:
                    min_loc = j
            li[i], li[min_loc] = li[min_loc], li[i]
```
时间复杂度：$O(n^2)$

### 插入排序(Insert Sort)
```Python
    def Insert_sort(li):
        for i in range(1, len(li)): #i 表示待插入数字的下标
            j = i - 1
            tmp = li[i]
            while li[j] > tmp and j >= 0:
                li[j+1] = li[j]
                j -= 1
            li[j+1] = tmp
```
时间复杂度：$O(n^2)$

## 进阶排序
### 快速排序
思路：
* 取一个元素p(左侧第一个第一个元素)，使p归位：左侧元素均小于p，右侧元素均大于
* 记录下该元素最终的位置，将其分割出的左右两个子列表进行相同的操作，直至子列表的长度为1
```Python
def partition(li, left, right):
    tmp = li[left] #取出左边第一个数
    while left < right:
        while left < right and li[right] >= tmp: #从右边找一个比tmp小的数
            right -= 1
        li[left] = li[right] #找出的值写入左边的空位上
        while left < right and li[left] <= tmp: #从左边找一个比tmp大的数
            left += 1
        li[right] = li[left] #找出的值写入右边的空位上
    li[left] = tmp #最初找出的值写到最终的空位上
    return left #返回mid的值(将在Quick_sort函数中使用)

def Quick_sort(li, left, right):
    if left < right:
        mid = partition(li, left, right)
        Quick_sort(li, left, mid-1)
        Quick_sort(li, mid+1, right)
```
时间复杂度：$O(n\log n)$
但对于最坏的情况，即原本列表是倒序的，快排的时间复杂度为$O(n^2)$
解决方案：随机取值进行归位，而不是取最左边的值，将最左边的数与列表中剩下的数交换顺序

### 堆排序
#### 基础知识
* 相关概念：
  * 树
  * 二叉树：度不超过2的树
    * 满二叉树：每个层的节点都达到了最大值
    * 完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的节点都集中在最左边的若干位置的二叉树（最下一排可以不满，但是必须从左边依次排过来）
* **顺序存储**的二叉树的实现
用列表来存：
* $父节点下标\times2+1=左孩子节点下标$
* $父节点下标\times2+2=右孩子节点下标$
* $(孩子节点下标-1)//2=父节点下标$
#### 堆
* 堆：一种特殊的完全二叉树
  * 大根堆：任意父节点的值都比其孩子节点大
  * 小根堆：任意父节点的值都比其孩子节点小
* 堆的向下调整性质
#### 堆排序过程
* 建立堆（农村包围城市）
* 得到堆顶元素，为最大元素
* 去掉堆顶，将堆的最后一个元素放到堆顶，再通过一次堆的向下调整使堆变得有序
* 堆顶元素为第二大元素
* 重复步骤3，直到堆变空
```Python
def sift(li, low, high): #调整函数(假设节点左右子树都是堆，但自身不是堆)
    i = low #i最开始指向根节点
    j = 2 * i + 1 #左孩子
    tmp = li[low] #把堆顶存起来
    while j <= high: #只要j位置有数
        if j + 1 <= high and li[j+1] > li[j]: # 如果右孩子比左孩子大且右孩子不越界
            j = j + 1
        if tmp < li[j]:
            li[i] = li[j]
            i = j #往下看一层，更新 i,j
            j = 2 * i + 1
#-------------------------------------------------------------------------------
        else:                                                       #可整体写为       else:
            li[i] = tmp #将tmp放到某一级领导的位置上，跳出循环                              break
            break                                                   #            li[i] = tmp
    else:
        li[i] = tmp #将tmp放到一个最低级的位置上，跳出循环
# -------------------------------------------------------------------------------
def Heap_sort(li):
    #先构造堆
    n = len(li)
    for i in range((n-2)//2, -1, -1): #遍历每一个待调整的父节点(从下往上)
        sift(li, i, n-1) #high仅有一个作用，就是判断j是否越界，故n-1就够用了
    #建堆完成
    #开始排序
    for i in range(n-1, -1, -1): #i指向当前堆的最后一个元素
        li[0], li[i] = li[i], li[0] #将最大的元素排在末尾
        sift(li, 0, i-1) #向下调整一次
```
时间复杂度：$O(n\log n)$
Python内置模块heapq
```Python
    import heapq #q代表queue 优先队列
    heapq.heapify(li) #建堆(小根堆)
    heapq.heappop(li) #弹出一个最小的元素
```